// code by ChatGPT (OpenAI), 2026
package ch.alpine.tensor.num;

import java.math.BigInteger;
import java.util.Optional;
import java.util.OptionalLong;

/** Tonelli-Shanks algorithm implementation
 * Generated by ChatGPT (OpenAI), 2026
 * Based on standard Tonelli-Shanks algorithm */
/* package */ enum TonelliShanks {
  ;
  private static final BigInteger _3 = BigInteger.valueOf(3);
  private static final BigInteger _4 = BigInteger.valueOf(4);

  /** Computes x such that x^2 ≡ n (mod p), or -1 if no solution exists
   * 
   * @param value
   * @param prime
   * @return */
  public static Optional<BigInteger> of(BigInteger value, BigInteger prime) {
    if (value.signum() == 0)
      return Optional.of(BigInteger.ZERO);
    if (prime.equals(BigInteger.TWO))
      return Optional.of(value);
    // Check n^(p-1)/2 ≡ 1 (mod p) using Euler's criterion
    if (!value.modPow(prime.subtract(BigInteger.ONE).shiftRight(1), prime).equals(BigInteger.ONE))
      return Optional.empty();
    // If p ≡ 3 (mod 4), simple solution
    if (prime.mod(_4).equals(_3))
      return Optional.of(value.modPow(prime.add(BigInteger.ONE).shiftRight(2), prime));
    // Factor p-1 = q * 2^s with q odd
    BigInteger q = prime.subtract(BigInteger.ONE);
    int s = 0;
    while (q.and(BigInteger.ONE).equals(BigInteger.ZERO)) {
      q = q.shiftRight(1);
      s++;
    }
    // Find a quadratic non-residue z
    BigInteger z = BigInteger.TWO;
    while (z.modPow(prime.subtract(BigInteger.ONE).shiftRight(1), prime).equals(BigInteger.ONE))
      z = z.add(BigInteger.ONE);
    BigInteger c = z.modPow(q, prime);
    BigInteger x = value.modPow(q.add(BigInteger.ONE).shiftRight(1), prime);
    BigInteger t = value.modPow(q, prime);
    int m = s;
    while (!t.equals(BigInteger.ONE)) {
      int i = 1;
      BigInteger temp = t.multiply(t).mod(prime);
      while (!temp.equals(BigInteger.ONE)) {
        temp = temp.multiply(temp).mod(prime);
        i++;
        if (i == m)
          return Optional.empty();
      }
      BigInteger b = c.modPow(BigInteger.ONE.shiftLeft(m - i - 1), prime);
      x = x.multiply(b).mod(prime);
      t = t.multiply(b).multiply(b).mod(prime);
      c = b.multiply(b).mod(prime);
      m = i;
    }
    return Optional.of(x);
  }

  /** @param value
   * @param prime
   * @return */
  public static OptionalLong of(long value, long prime) {
    Optional<BigInteger> optional = of(BigInteger.valueOf(value), BigInteger.valueOf(prime));
    return optional.map(BigInteger::longValueExact).map(OptionalLong::of).orElseGet(OptionalLong::empty);
  }
}
